#! /usr/bin/env ruby

require 'bundler'
Bundler.setup(:default, :development)

require 'date'
require 'git'
require 'guard'
require 'safe_yaml'
require 'stringex_lite'
require 'thor'

class SiteTool < Thor
  include Thor::Actions

  desc "post TITLE", "create a post"
  option :editor, :default => ENV['VISUAL'] || ENV['EDITOR'] || 'vi'
  option :date, :default => Time.now.to_s
  def post(title)
    begin
      date = Date.parse(options[:date])
    rescue
      say_status(:error, "Could not parse '#{options[:date]}'", :red)
      exit 1
    end
    slug = title.to_url
    dest = path_to(:_posts)

    shell.mute { empty_directory(dest) }

    filename = "#{date.strftime('%Y-%m-%d')}-#{slug}.md"
    create_file(path_to(dest, filename)) do
      ["---",
       "layout: news",
       "title: #{title}",
       "---",
       ""].join("\n")
    end

    exec(options[:editor], path_to(dest, filename))
  end

  ISOLATION_FILE = ".isolation_config.yml"

  desc "isolate FILE ...", "work on a file or files in isolation (globs are allowed)"
  long_desc <<-LONGDESC
    Jekyll's regeneration capability is limited to regenerating the
    entire site.  This option will ignore all files except the ones you
    specify in order to speed regeneration.

    Keep in mind that Jekyll's exclusion mechanism is not aware of
    subdirectories so this command operates on the basename of all files
    that match the file or glob you provide.
  LONGDESC
  def isolate(*files)
    SafeYAML::OPTIONS[:default_mode] = :safe

    old_config = YAML.load_file("_config.yml")
    config = {}

    pages = []
    pages << %w(md html textile markdown mkd mkdn).map do |ext|
      Dir.glob("**/*.#{ext}")
    end
    pages.flatten!.reject! { |f| File.fnmatch?('_site/*', f) }

    pages.select! do |p|
      content = File.read(p)
      # Jekyll only renders pages with YAML frontmatter.  See Jekyll's
      # convertible.rb read_yaml method.
      content =~ /\A(---\s*\n.*?\n?)^(---\s*$\n?)/m
    end
    config['exclude'] = pages.map { |f| File.basename(f) }
    config['exclude'] += old_config['exclude'] || []

    # Due to our use of pagination, Jekyll wants an index.html
    config['include'] = %w(*.less *.js *.css *.png 404.html index.html)
    files.each do |glob|
      matches = Dir.glob(glob)
      config['include'] += matches.map do |f|
        ext = File.extname(f)
        # Remove file extension
        name = File.basename(f, ext)
        # Jekyll won't serve files that it is ignoring so we need to match
        # the original extension (usually .md) and the rendered extension
        # (.html)
        "#{name}.*"
      end
    end

    create_file(ISOLATION_FILE, YAML.dump(config))
    begin
      invoke(:serve, [])
    ensure
      remove_file(ISOLATION_FILE)
    end
  end

  desc "serve", "render and serve the site"
  def serve
    guard_thread = Guard.start
    guard_thread.join
  end

  APP_ID = "5343494ce0b8cdec71000349"
  APP_NAME = "website"
  DOMAIN_NAME = "candlepinproject"

  desc "bootstrap", "add openshift configuration"
  def bootstrap
    repo = Git.open(SiteTool.source_root)
    repo.config("rhc.app-id", APP_ID)
    repo.config("rhc.app-name", APP_NAME)
    repo.config("rhc.domain-name", DOMAIN_NAME)
    repo.add_remote("openshift", "ssh://#{APP_ID}@#{APP_NAME}-#{DOMAIN_NAME}.rhcloud.com/~/git/#{APP_NAME}.git")
    repo.remote("openshift").fetch
  end

  # Methods in the no_tasks block are not exposed to users
  no_tasks do
    def self.source_root
      File.expand_path("..", File.dirname(__FILE__))
    end

    # Builds a path within the source_root
    def path_to(*args)
      args = args.map(&:to_s)
      File.join(*args)
    end
  end
end

SiteTool.start(ARGV)
